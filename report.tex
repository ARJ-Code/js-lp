\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{titling}
\usepackage{float}
\usepackage[text={18cm,21cm},centering]{geometry}
\usepackage{hyperref} \hypersetup{ colorlinks=true, linkcolor=blue, filecolor=magenta,
urlcolor=blue, }
\usepackage{listings}
\usepackage{xcolor}

% Definir colores adicionales si es necesario
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}
\definecolor{lightgray}{rgb}{0.9, 0.9, 0.9}
\definecolor{green}{rgb}{0, 0.5, 0}
\definecolor{blue}{rgb}{0, 0, 1}
\definecolor{red}{rgb}{1, 0, 0}


\lstdefinelanguage{JavaScript}{
  keywords={break, case, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with, let, const, export, import, class, extends, super, console},
  sensitive=true,
  comment=[l]//,
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]"
}

% Definición del lenguaje Python para listings
\lstdefinelanguage{Python}{
  keywords={and, as, assert, break, class, continue, def, del, elif, else, except, exec, finally, for, from, global, if, import, in, is, lambda, not, or, pass, print, raise, return, try, while, with, yield, True, False, None},
  sensitive=true,
  comment=[l]\#,
  morecomment=[s]{"""}{"""},
  morestring=[b]',
  morestring=[b]",
  morestring=[b]'''
  morestring=[b]"""
}

\lstset{ 
  language=JavaScript,        % El lenguaje de programación
  basicstyle=\ttfamily\footnotesize, % El estilo básico para el código
  keywordstyle=\color{blue},  % Color para las palabras clave
  stringstyle=\color{red},    % Color para las cadenas de texto
  commentstyle=\color{green}, % Color para los comentarios
  backgroundcolor=\color{lightgray!20}, % Color de fondo
  frame=single,               % Añade un marco alrededor del código
  numbers=left,               % Añade números de línea a la izquierda
  numberstyle=\tiny\color{gray}, % Estilo de los números de línea
  breaklines=true,            % Permite el salto de línea automático
  showstringspaces=false      % No muestra los espacios en las cadenas
}

\begin{document}


\begin{titlepage}
      \centering
      {\bfseries\LARGE Universidad de La Habana \par}
      \vspace{1cm}
      {\scshape\Large Facultad de Matemática y Computación \par}
      \vspace{3cm}
      {\scshape\Huge Lenguajes de Programación\\ Seminario 4 (JavaScript) \par}
      \vfill

      {\Large Juan Carlos Espinosa Delgado C-411 \par}
      {\Large Raudel Alejandro Gómez Molina C-411 \par}
      {\Large Alex Sierra Alcalá C-411 \par}
      \vfill
      {\href{https://github.com/ARJ-Code/js-lp}{Proyecto en github} \par}
\end{titlepage}

\section{Introducción}

\subsection{Propósito del Surgimiento de JavaScript}

JavaScript nació en 1995 de la mano de Brendan Eich en Netscape Communications, con el propósito de permitir a los
desarrolladores agregar interactividad a las páginas web. A diferencia de lenguajes como Java, que requerían
compilación y eran más complejos, JavaScript fue diseñado para ser sencillo, interpretado y embebido directamente en
los navegadores. Su objetivo principal era facilitar la manipulación del Document Object Model (DOM) y permitir la
creación de experiencias web más dinámicas y atractivas para los usuarios.

\subsection{Problemas de Compatibilidad de los Navegadores Antes de la Adopción de ECMAScript 6}

Antes de la estandarización y adopción de ECMAScript 6 (ES6) en 2015, el ecosistema de JavaScript enfrentaba serios
desafíos de compatibilidad entre navegadores. Cada navegador (Internet Explorer, Netscape, Firefox, Chrome, Safari,
etc.) implementaba el lenguaje de manera ligeramente diferente, lo que resultaba en:

\begin{itemize}
      \item Inconsistencias en las API y Funcionalidades: Los desarrolladores tenían que escribir código específico
            para cada navegador o usar librerías como jQuery para abstraer estas diferencias.
      \item Problemas de Rendimiento: Diferentes motores de JavaScript (como V8 en Chrome, SpiderMonkey en Firefox)
            tenían variaciones significativas en cómo ejecutaban el código, lo que afectaba la experiencia del usuario.
      \item Falta de Características Modernas: Sin una actualización estandarizada, los desarrolladores no podían
            aprovechar características modernas y eficientes en todos los navegadores, limitando la capacidad de innovación y la complejidad de las aplicaciones web.

\end{itemize}

\subsection{Actual Uso y Versatilidad de JavaScript}

Desde la adopción de ES6 y posteriores actualizaciones de ECMAScript, JavaScript ha evolucionado enormemente,
convirtiéndose en uno de los lenguajes de programación más versátiles y ampliamente utilizados en la industria del
software. Actualmente, JavaScript es la columna vertebral del desarrollo web moderno, gracias a sus siguientes
características:

\begin{itemize}
      \item Compatibilidad y Estandarización: Con la adopción de ES6 y versiones posteriores, los navegadores modernos
            ofrecen una implementación más consistente y completa del lenguaje, reduciendo significativamente los problemas
            de compatibilidad.
      \item Versatilidad: JavaScript no solo se utiliza en el desarrollo frontend con tecnologías como React, Angular y
            Vue.js, sino también en el backend con Node.js, lo que permite a los desarrolladores usar un solo lenguaje en
            toda la stack de aplicaciones.
      \item Ecosistema Rico: Un vasto ecosistema de herramientas, librerías y frameworks facilita el desarrollo rápido
            y eficiente de aplicaciones web, móviles (React Native), de escritorio (Electron) e incluso en Internet de las
            Cosas (IoT).
      \item  Innovación Continua: La comunidad de JavaScript y los comités de ECMAScript siguen introduciendo nuevas
            características y mejoras que mantienen al lenguaje relevante y poderoso para enfrentar los desafíos tecnológicos
            actuales.
\end{itemize}

En resumen, JavaScript ha recorrido un largo camino desde sus inicios como un simple lenguaje de scripting para
navegadores, hasta convertirse en una pieza fundamental del desarrollo de software moderno. Su evolución ha permitido
resolver problemas críticos de compatibilidad y ha potenciado su uso en múltiples contextos, demostrando una
versatilidad y adaptabilidad que siguen siendo esenciales en la industria tecnológica actual.

\section{Problemas Estructurales de JavaScript y el Surgimiento de TypeScript}

\subsection{Problemas Estructurales de JavaScript}

A pesar de su popularidad y versatilidad, JavaScript presenta varios problemas estructurales que pueden complicar
el desarrollo de aplicaciones complejas. Estos problemas incluyen:

\begin{enumerate}
      \item Tipado Dinámico y Falta de Tipos Estáticos:
            \begin{itemize}
                  \item JavaScript es un lenguaje de tipado dinámico, lo que significa que las variables pueden cambiar de
                        tipo durante la ejecución. Esto puede llevar a errores difíciles de detectar y depurar.
                  \item La falta de verificación de tipos en tiempo de compilación puede resultar en problemas de
                        consistencia y errores de tipo que solo se manifiestan en tiempo de ejecución.
            \end{itemize}
      \item Problemas de Mantenimiento y Escalabilidad:
            \begin{itemize}
                  \item En proyectos grandes, la ausencia de un sistema de tipos robusto puede hacer que el código sea
                        difícil de mantener y refactorizar.
                  \item La gestión de grandes bases de código puede volverse compleja debido a la falta de estructura y
                        organización que un sistema de tipos podría proporcionar.
            \end{itemize}
      \item Herencia Prototípica:
            \begin{itemize}
                  \item Aunque JavaScript soporta herencia a través de prototipos, esta puede ser menos intuitiva y más
                        propensa a errores que la herencia basada en clases, especialmente para desarrolladores
                        provenientes de otros lenguajes orientados a objetos.
            \end{itemize}
      \item Gestión de Módulos:
            \begin{itemize}
                  \item Antes de ES6, JavaScript no tenía un sistema nativo de módulos, lo que dificultaba la
                        organización y reutilización del código.
                  \item La gestión de dependencias y la modularización del código eran complejas y dependían de
                        herramientas y patrones externos.
            \end{itemize}
      \item Problemas de Asincronía:
            \begin{itemize}
                  \item El manejo de operaciones asíncronas en JavaScript, tradicionalmente mediante callbacks, puede
                        llevar al llamado "callback hell", haciendo que el código sea difícil de leer y mantener.
            \end{itemize}
\end{enumerate}

\subsection{ El Surgimiento de TypeScript}

Para abordar muchos de estos problemas, Microsoft introdujo TypeScript en 2012. TypeScript es un superconjunto de
JavaScript que agrega tipos estáticos y otras características avanzadas, con el objetivo de mejorar la productividad
del desarrollo y la mantenibilidad del código.

\begin{enumerate}
      \item Tipos Estáticos:
            \begin{itemize}
                  \item TypeScript introduce un sistema de tipos estáticos que permite a los desarrolladores definir y
                        verificar los tipos de variables, funciones y objetos en tiempo de compilación.
                  \item Esto ayuda a identificar errores de tipo antes de que el código se ejecute, mejorando la
                        confiabilidad y reduciendo el número de errores en tiempo de ejecución.
            \end{itemize}
      \item Compatibilidad con JavaScript:
            \begin{itemize}
                  \item TypeScript es un superconjunto estricto de JavaScript, lo que significa que cualquier código
                        JavaScript válido es también un código TypeScript válido.
                  \item Esto permite a los desarrolladores adoptar TypeScript de manera incremental, comenzando con
                        archivos JavaScript existentes y agregando gradualmente tipos y características de TypeScript.
            \end{itemize}

      \item Mejor Herramientas y Soporte para IDE:
            \begin{itemize}
                  \item TypeScript ofrece una integración superior con editores de código y entornos de desarrollo
                        integrados (IDE), proporcionando autocompletado, refactorización y navegación mejorados.
                  \item Las herramientas de desarrollo se benefician del conocimiento del sistema de tipos, lo que
                        facilita la escritura y mantenimiento del código.
            \end{itemize}

      \item Clases y Herencia:
            \begin{itemize}
                  \item TypeScript introduce una sintaxis de clases más familiar para los desarrolladores que provienen
                        de otros lenguajes orientados a objetos, mejorando la legibilidad y el uso de patrones de diseño
                        orientados a objetos.
                  \item  Soporta herencia, encapsulación y polimorfismo de manera más intuitiva y estructurada.
            \end{itemize}
      \item Módulos y ES6+:
            \begin{itemize}
                  \item TypeScript soporta módulos ES6, permitiendo una mejor organización del código y gestión de
                        dependencias.
                  \item Aprovecha las características modernas de JavaScript, asegurando que el código esté alineado con
                        las mejores prácticas actuales.
            \end{itemize}
      \item Asincronía Mejorada:
            \begin{itemize}
                  \item TypeScript mejora el manejo de operaciones asíncronas mediante el uso de async/await,
                        proporcionando una sintaxis más clara y directa para el manejo de promesas y funciones asíncronas.
            \end{itemize}
\end{enumerate}

TypeScript ha surgido como una poderosa herramienta para superar muchas de las limitaciones estructurales de
JavaScript. Al agregar tipos estáticos, mejorar la organización del código y proporcionar una mejor experiencia
de desarrollo, TypeScript ayuda a los desarrolladores a escribir código más robusto, mantenible y escalable. Esto
ha llevado a su adopción creciente en la industria, especialmente para proyectos grandes y complejos donde las
ventajas de un sistema de tipos sólido son más evidentes.

\section{Modelo de objetos}

JavaScript está diseñado sobre un paradigma simple basado en objetos. Un objeto es una colección de pares de
<clave, valor> los cuales son llamados propiedades. El valor de una propiedad puede ser una función en cuyo caso
se conoce como método.

Esta representación de los objetos al igual que en otros lenguajes de programación intenta simular el comportamiento
de los objetos en la vida real.

\subsection{Inicializadores de los objetos}

Los inicializadores de objetos de se denominan también literales de objeto y utilizan la siguiente siguiente sintaxis:

\begin{lstlisting}
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
\end{lstlisting}

Las llaves de cada propiedad pueden ser cualquier expresión que pueda ser interpretada como un string,
por ejemplo un número, un literal de string o una variable cuyo valor pueda ser interpretado como un string.
Mientras que como valor de la propiedad puede aparecer cualquier expresión.

Los inicializadores de objetos son expresiones, y cada inicializador de
objeto da como resultado la creación de un nuevo objeto cada vez que se
ejecuta la instrucción en la que aparece. Los inicializadores de objetos idénticos crean objetos distintos que no se comparan entre sí como iguales.

Las propiedades no asignadas de un objeto son \textbf{undefined} (y no \textbf{null}).

\subsection{Función constructora}

Otra manera de inicializar los objetos es mediante el uso de una función constructora, mediante el uso de la
de \textbf{this}.

Por ejemplo para crear un objeto \textbf{Car} con las propiedades \textbf{make}, \textbf{model} y \textbf{year}
lo hacemos de la siguiente manera:

\begin{lstlisting}
function Car(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
}
\end{lstlisting}

Luego podemos crear un nuevo objeto mediante el uso de \textbf{new}.

\begin{lstlisting}
const myCar = new Car("Eagle", "Talon TSi", 1993);
\end{lstlisting}

\subsection{Acceso a las propiedades y eliminación de una propiedad}

Acceso a las Propiedades

En JavaScript, se puede acceder a las propiedades de un objeto utilizando dos métodos principales:

\begin{enumerate}
      \item Notación de Punto: Se usa cuando se conoce el nombre de la propiedad y es un identificador válido.
\begin{lstlisting}
let person = {
name: 'John',
age: 30
};
console.log(person.name); // Output: John      
\end{lstlisting}

      \item Notación de Corchetes: Se usa cuando el nombre de la propiedad es dinámico o no es un identificador válido.
\begin{lstlisting}
let propertyName = 'age';
console.log(person[propertyName]); // Output: 30            
\end{lstlisting}

\end{enumerate}

Listar Todas las Propiedades

Para listar todas las propiedades de un objeto, se pueden utilizar varios métodos:

\begin{enumerate}
      \item \textbf{for...in Loop}: Recorre todas las propiedades enumerables de un objeto.
\begin{lstlisting}
for (let key in person) {
      console.log(key + ': ' + person[key]);
}
\end{lstlisting}

      \item \textbf{Object.keys()}: Devuelve un array con las propiedades enumerables propias del objeto.
\begin{lstlisting}
let keys = Object.keys(person);
console.log(keys); // Output: ['name', 'age']
\end{lstlisting}

      \item \textbf{Object.values()}: Devuelve un array con los valores de las propiedades enumerables propias del objeto.
\begin{lstlisting}
let values = Object.values(person);
console.log(values); // Output: ['John', 30]
\end{lstlisting}

      \item \textbf{ Object.entries()}: Devuelve un array de arrays, donde cada sub-array contiene un par clave-valor de las propiedades enumerables propias del objeto.
\begin{lstlisting}
let entries = Object.entries(person);
console.log(entries); // Output: [['name', 'John'], ['age', 30]]
\end{lstlisting}
\end{enumerate}


\subsection{Prototipos}

En programación, la herencia se refiere a la transmisión de características de un padre a un hijo para que un nuevo fragmento de código pueda reutilizarse
y basarse en las características de uno existente. JavaScript implementa la herencia mediante el uso de objetos. Cada objeto tiene un enlace interno a otro
objeto llamado su prototipo. Ese objeto prototipo tiene un prototipo propio, y así sucesivamente hasta que se llega a un objeto con su prototipo. Por definición,
no tiene prototipo y actúa como el eslabón final de esta cadena de prototipos. Es posible mutar cualquier miembro de la cadena de prototipos o incluso intercambiar
el prototipo en tiempo de ejecución, por lo que conceptos como el envío estático no existen en JavaScript.

Los objetos JavaScript son "bolsas" dinámicas de propiedades (denominadas propiedades propias). Los objetos JavaScript tienen un vínculo a un objeto prototipo.
Al intentar acceder a una propiedad de un objeto, la propiedad no solo se buscará en el objeto, sino también en el prototipo del objeto, el prototipo del prototipo,
y así sucesivamente hasta que se encuentre una propiedad con un nombre coincidente o se alcance el final de la cadena del prototipo.

Para modificar o crear el prototipo de un objeto se puede hacer uso de la propiedad \textbf{\_\_proto\_\_}.

\begin{lstlisting}
const o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
  },
};

// o.[[Prototype]] has properties b and c.
// o.[[Prototype]].[[Prototype]] is Object.prototype (we will explain
// what that means later).
// Finally, o.[[Prototype]].[[Prototype]].[[Prototype]] is null.
// This is the end of the prototype chain, as null,
// by definition, has no [[Prototype]].
// Thus, the full prototype chain looks like:
// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> Object.prototype ---> null

console.log(o.a); // 1
// Is there an 'a' own property on o? Yes, and its value is 1.

console.log(o.b); // 2
// Is there a 'b' own property on o? Yes, and its value is 2.
// The prototype also has a 'b' property, but it's not visited.
// This is called Property Shadowing

console.log(o.c); // 4
// Is there a 'c' own property on o? No, check its prototype.
// Is there a 'c' own property on o.[[Prototype]]? Yes, its value is 4.

console.log(o.d); // undefined
// Is there a 'd' own property on o? No, check its prototype.
// Is there a 'd' own property on o.[[Prototype]]? No, check its prototype.
// o.[[Prototype]].[[Prototype]] is Object.prototype and
// there is no 'd' property by default, check its prototype.
// o.[[Prototype]].[[Prototype]].[[Prototype]] is null, stop searching,
// no property found, return undefined.

\end{lstlisting}

\subsection{Herencia}

Los objetos en JavaScript no poseen métodos al igual que los lenguajes de programación orientados  a objetos,
en cambio cualquier función puede ser atribuida a un objeto en forma de una propiedad. En consecuencia el
comportamiento de un objeto padre puede ser heredado a un objeto hijo mediante una cadena de prototipos como vimos
en la sección anterior.

\begin{lstlisting}
const parent = {
  value: 2,
  method() {
    return this.value + 1;
  },
};

console.log(parent.method()); // 3
// When calling parent.method in this case, 'this' refers to parent

// child is an object that inherits from parent
const child = {
  __proto__: parent,
};
console.log(child.method()); // 3
// When child.method is called, 'this' refers to child.
// So when child inherits the method of parent,
// The property 'value' is sought on child. However, since child
// doesn't have an own property called 'value', the property is
// found on the [[Prototype]], which is parent.value.

child.value = 4; // assign the value 4 to the property 'value' on child.
// This shadows the 'value' property on parent.
// The child object now looks like:
// { value: 4, __proto__: { value: 2, method: [Function] } }
console.log(child.method()); // 5
// Since child now has the 'value' property, 'this.value' means
// child.value instead

\end{lstlisting}

\subsection{Incializar objetos usando las bondades de los prototipos}

Supongamos que queremos crear varios objetos \textbf{Box} los cuales tendrán una propiedad \textbf{value} y un método
\textbf{getValue}. Podríamos hacerlo de la siguiente manera:

\begin{lstlisting}
const boxes = [
  { value: 1, getValue() { return this.value; } },
  { value: 2, getValue() { return this.value; } },
  { value: 3, getValue() { return this.value; } },
];
\end{lstlisting}

Esta implementación no es muy adecuada ya que estamos creando un nuevo espacio de memoria para cada instancia
de \textbf{getValue}, en cambio podemos hacer que estos objetos compartan la implementación de \textbf{getValue}
mediante el uso de un prototipo.

\begin{lstlisting}
// A constructor function
function Box(value) {
  this.value = value;
}

// Properties all boxes created from the Box() constructor
// will have
Box.prototype.getValue = function () {
  return this.value;
};

const boxes = [new Box(1), new Box(2), new Box(3)];
\end{lstlisting}

De esta manera los 3 objetos compartirán la misma instancia de la función \textbf{getValue}.

\subsection{Azúcar sintáctica para las funciones constructoras}

Sin embargo el lenguaje nos proporciona una azúcar sintáctica para esta implementación mediante
el uso de \textbf{class}:

\begin{lstlisting}
class Box {
  constructor(value) {
    this.value = value;
  }

  // Methods are created on Box.prototype
  getValue() {
    return this.value;
  }
}
\end{lstlisting}

y ahora la herencia se puede implementar de la siguiente manera.

\begin{lstlisting}
class Box {
  constructor(value) {
    this.value = value;
  }

  getValue() {
    return this.value;
  }
}

class ColoredBox extends Box {
  constructor(value, color) {
    // Llama al constructor de la clase padre
    super(value);
    this.color = color;
  }

  getColor() {
    return this.color;
  }

  getValue() {
    return `Value: ${this.value}, Color: ${this.color}`;
  }
}

// Ejemplo de uso
const myBox = new ColoredBox(10, 'red');
console.log(myBox.getValue());  // Output: Value: 10, Color: red
console.log(myBox.getColor());  // Output: red

\end{lstlisting}

\subsection{Definiendo métodos get y set}

Al igual que en los lenguajes de programación orientados a objetos en JavaScript es posible definir
el método \textbf{get} y \textbf{set}, asignándole un método las llaves \textbf{get} y \textbf{set}
del objeto respectivamente.

\begin{lstlisting}
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
\end{lstlisting}

\subsection{Ventajas y desventajas del modelo de objetos basado en prototipos }

Ventajas y Desventajas del Modelo de Objetos Basado en Prototipos

Ventajas

\begin{enumerate}
      \item Flexibilidad y Dinamismo:
            \begin{itemize}
                  \item Modificación Dinámica: Los objetos pueden ser modificados en tiempo de ejecución, lo que permite
                        cambiar su estructura y comportamiento dinámicamente.
                  \item Extensión de Objetos Existentes: Es fácil añadir propiedades y métodos a objetos ya existentes sin
                        necesidad de definir nuevas clases.
            \end{itemize}
      \item Simplicidad Conceptual:
            \begin{itemize}
                  \item Sin Necesidad de Clases: No requiere la definición de clases; en cambio, los objetos pueden ser
                        creados directamente y extendidos de manera simple.
                  \item Reutilización Directa: Permite la reutilización directa de objetos existentes como prototipos
                        para nuevos objetos.
            \end{itemize}
      \item Herencia de Prototipos:
            \begin{itemize}
                  \item Cadena de Prototipos: La cadena de prototipos permite una forma sencilla y efectiva de herencia y
                        reutilización de propiedades y métodos.
                  \item Mutación Prototípica: Se pueden cambiar los prototipos en tiempo de ejecución, permitiendo ajustar
                        dinámicamente la herencia y el comportamiento de los objetos.
            \end{itemize}
      \item Simplicidad en el Envío de Mensajes:
            \begin{itemize}
                  \item Flexibilidad en el Envío: La resolución de métodos es dinámica y se realiza a través de la cadena
                        de prototipos, lo que permite una mayor flexibilidad en la ejecución de métodos.
            \end{itemize}
\end{enumerate}

Desventajas

\begin{enumerate}
      \item Complejidad en Grandes Proyectos:
            \begin{itemize}
                  \item Mantenimiento: En proyectos grandes, la falta de estructura de clases puede llevar a un código
                        desorganizado y difícil de mantener.
                  \item Refactorización: La flexibilidad y dinamismo pueden dificultar la refactorización segura del
                        código, especialmente en proyectos a gran escala.
            \end{itemize}
      \item Rendimiento:
            \begin{itemize}
                  \item Coste de Búsqueda en la Cadena de Prototipos: La búsqueda de propiedades y métodos a través de la
                        cadena de prototipos puede introducir sobrecarga de rendimiento.
                  \item Mutaciones Dinámicas: Las modificaciones dinámicas en los prototipos pueden afectar negativamente
                        al rendimiento del motor de JavaScript, que debe adaptarse a los cambios en tiempo de ejecución.
            \end{itemize}
      \item Inconsistencias y Errores:
            \begin{itemize}
                  \item Propiedades Heredadas: La herencia de propiedades y métodos a través de prototipos puede llevar a
                        errores si no se manejan cuidadosamente las propiedades sobrescritas o heredadas.
                  \item Problemas de Contexto: El uso del contexto (this) en JavaScript puede ser confuso y propenso a
                        errores, especialmente cuando se utilizan funciones como métodos.
            \end{itemize}
      \item Curva de Aprendizaje:
            \begin{itemize}
                  \item Concepto de Prototipos: Los desarrolladores acostumbrados a lenguajes basados en clases pueden
                        encontrar confuso el modelo de prototipos y la herencia prototípica.
                  \item Contexto Dinámico: La dinámica del contexto y la necesidad de entender cómo funcionan los enlaces
                        de prototipos pueden añadir complejidad para los nuevos desarrolladores.
            \end{itemize}
\end{enumerate}
\section{Jerarquía haciendo uso de prototipos}
Al utilizar prototipos, podemos crear una jerarquía de objetos donde cada subclase hereda las propiedades y métodos de su clase base. Esto nos permite modelar relaciones "es un" entre objetos de forma flexible y extensible

\begin{lstlisting}
// Base class Vehicle
function Vehicle() {
  this.wheels = 4;
  this.engine = true;
  this.start = function() {
    console.log("The vehicle has started!");
  };
}

// Subclass Car
function Car() {
  // Inherits properties and methods from the base class Vehicle
  Vehicle.call(this);
  this.doors = 4;
  this.accelerate = function() {
    console.log("The car is accelerating!");
  };
}

// Subclass Motorcycle
function Motorcycle() {
  // Inherits properties and methods from the base class Vehicle
  Vehicle.call(this);
  this.wheels = 2;
  this.helmet = true;
  this.drive = function() {
    console.log("The motorcycle is driving!");
  };
}

// Subclass Truck
function Truck() {
  // Inherits properties and methods from the base class Vehicle
  Vehicle.call(this);
  this.wheels = 6;
  this.trailer = true;
  this.transport = function() {
    console.log("The truck is transporting!");
  };
}

// Create instances of the subclasses
const car = new Car();
const motorcycle = new Motorcycle();
const truck = new Truck();

// Call methods on the instances
car.start(); // The vehicle has started!
car.accelerate(); // The car is accelerating!

motorcycle.start(); // The vehicle has started!
motorcycle.drive(); // The motorcycle is driving!

truck.start(); // The vehicle has started!
truck.transport(); // The truck is transporting!


\end{lstlisting}



En este ejemplo, la clase base Vehiculo define las propiedades y métodos comunes a todos los vehículos. Las subclases Carro, Moto y Camion heredan de la clase base y añaden sus propias propiedades y métodos específicos.


Ahora veremos otro ejemplo de uso de prototipos con un enfoque diferente.
\begin{lstlisting}
// Base class Person
function Person() {
  this.name = "Juan";
}

Person.prototype.speak = function() {
  console.log("Hello!");
};

// Creating a subclass using Person.prototype
function Student() {
  Person.prototype.constructor.call(this); // Invoke the base class constructor
  this.registrationNumber = "12345";
}

Student.prototype.study = function() {
  console.log("I am studying!");
};

// Create an object of the Person class
const juan = new Person();
console.log(juan.name); // Juan
juan.speak(); // Hello!

// Create an object of the Student class
const studentJuan = new Student();
console.log(studentJuan.name); // Juan
console.log(studentJuan.registrationNumber); // 12345
studentJuan.speak(); // Hello!
studentJuan.study(); // I am studying!

\end{lstlisting}

Diferencias clave entre ambos ejemplos de uso:
\begin{itemize}
      \item Momento de la asignación: Person.prototype se asigna después de definir la función constructora, mientras que vehicle.call(this) se llama desde dentro del constructor de la subclase.
      \item Propósito: Person.prototype agrega propiedades y métodos al prototipo del constructor, mientras que vehicle.call(this) invoca al constructor de la clase base.
      \item Uso: Person.prototype es más común en JavaScript moderno para crear jerarquías de objetos, mientras que vehicle.call(this) se utiliza principalmente en situaciones heredadas o cuando se requiere un control más explícito sobre la invocación del constructor de la clase base.

\end{itemize}

\section{Implementación en Python del modelo de objetos de JavaScript}

\begin{lstlisting}
class JavascriptObject:
    def __init__(self, prototype=None):
        if prototype is not None:
            self.__dict__['prototype'] = prototype

    def __getattr__(self, item):
        if item in self.__dict__:
            return self.__dict__[item]
        if 'prototype' in self.__dict__:
            return self.__dict__['prototype'].__getattr__(item)
        raise AttributeError(
            f"'{type(self).__name__}' object has no attribute '{item}'")

    def __setattr__(self, key, value):
        self.__dict__[key] = value

    def keys(self):
        proto_keys = self.__dict__['prototype'].keys(
        ) if 'prototype' in self.__dict__ else []
        return [k for k in set(list(self.__dict__.keys())+proto_keys) if k != 'prototype']

    def values(self):
        return [self.__getattr__(k) for k in self.keys()]

    def __iter__(self):
        return self.keys()


# Ejemplo de uso:
animal_proto = JavascriptObject()
animal_proto.speak = lambda self: print(f'{self.name} makes a noise.')

dog_proto = JavascriptObject(animal_proto)
dog_proto.speak = lambda self: print(f'{self.name} barks.')

dog = JavascriptObject(dog_proto)
dog.name = 'Rex'
dog.speak(dog)
print(dog.values())
\end{lstlisting}

\section{JavaScript orientado a objetos}

La programación orientada a objetos consiste en modelar un sistema como una 
colección de objetos, donde cada objeto representa algún aspecto particular 
del sistema. Los objetos contienen tanto funciones como datos. 
Un objeto proporciona una interfaz pública a otro código que desea utilizarlo, 
pero mantiene su propio estado interno privado; a otras partes del sistema 
no les importa lo que está sucediendo dentro del objeto. Veamos como se 
refleja esto en JavaScript.

\subsection{Encapsulamiento}

Los objetos proporcionan una interfaz a otro código que desea utilizarlos, 
pero mantienen su propio estado interno. El estado interno del objeto permanece 
privado, lo que significa que solo puede ser accedido por los propios métodos 
del objeto, no por otros objetos. Mantener el estado interno de un objeto 
privado y, en general, hacer una clara división entre su interfaz pública y 
su estado interno privado, se llama encapsulamiento. Esta característica 
permite al programador cambiar la implementación interna de un objeto sin 
tener que buscar y actualizar todo el código que lo utiliza. En JavaScript, 
esto se puede lograr utilizando closures para simular propiedades privadas.

\begin{lstlisting}
function Persona(nombre, edad) {
      this.nombre = nombre;
      let _edad = edad; // Propiedad privada
      
      this.getEdad = function() {
            return _edad;
      };
      
      this.setEdad = function(nuevaEdad) {
            if (nuevaEdad > 0) {
                  _edad = nuevaEdad;
            }
      };
      }
      
let juan = new Persona("Juan", 30);
console.log(juan.nombre); // "Juan"
console.log(juan.getEdad()); // 30
juan.setEdad(31);
console.log(juan.getEdad()); // 31
\end{lstlisting}

\subsection{Herencia}

Los constructores en JavaScript nos proporcionan algo parecido a una 
definición de clase, permitiéndonos definir la "forma" de un objeto, 
incluidos los métodos que contiene, en un solo lugar. Pero los prototipos 
también pueden ser utilizados con este fin. Por ejemplo, si un método se define en 
la propiedad prototipo de un constructor, entonces todos los objetos creados 
usando ese constructor obtienen ese método a través de su prototipo, y no 
necesitamos definirlo en el constructor. Por tanto la cadena de prototipos 
parece una forma natural de implementar la herencia. Pero vale la pena 
entender las diferencias entre estas características y los conceptos de 
POO "clásica" descritos anteriormente.

Primero, en la POO basada en clases, las clases y los objetos son dos 
conceptos separados, y los objetos siempre se crean como instancias de 
clases. Además, hay una distinción entre la característica utilizada para 
definir una clase (la sintaxis de la clase en sí) y la característica 
utilizada para instanciar un objeto (un constructor). En JavaScript, 
podemos y a menudo creamos objetos sin ninguna definición de clase 
separada, ya sea usando una función o un literal de objeto. Esto puede hacer 
que trabajar con objetos sea mucho más ligero que en la POO clásica.

En segundo lugar, aunque una cadena de prototipos se parece a una jerarquía 
de herencia y se comporta como tal en algunos aspectos, es diferente en 
otros. Cuando se instancia una subclase, se crea un solo objeto que combina 
propiedades definidas en la subclase con propiedades definidas más arriba 
en la jerarquía. Con el prototipado, cada nivel de la jerarquía está 
representado por un objeto separado, y están vinculados entre sí a través 
de la propiedad \_\_proto\_\_. El comportamiento de la cadena de prototipos 
es menos parecido a la herencia y más a la delegación. La delegación es un 
patrón de programación donde un objeto, cuando se le pide realizar una 
tarea, puede realizar la tarea él mismo o pedir a otro objeto (su delegado) 
que realice la tarea en su nombre. De muchas maneras, la delegación es una 
forma más flexible de combinar objetos que la herencia 
(por una cosa, es posible cambiar o reemplazar completamente al delegado en 
tiempo de ejecución).

Dicho esto, los constructores y prototipos pueden ser utilizados para 
implementar patrones de POO basada en clases en JavaScript. Pero usarlos 
directamente para implementar características como la herencia es complicado, 
por lo que JavaScript proporciona características adicionales, superpuestas 
al modelo de prototipo, que se relacionan más directamente con los conceptos 
de POO basada en clases.

\subsection{Polimorfismo}

El polimorfismo permite que diferentes objetos respondan de manera distinta 
a la misma llamada de método, y JavaScript permite modelar este comportamiento
usando prototiposi constructores

\begin{lstlisting}
function Animal(nombre) {
      this.nombre = nombre;
}
      
Animal.prototype.hablar = function() {
      console.log(this.nombre + " hace un ruido.");
};

function Perro(nombre) {
    Animal.call(this, nombre); // Herencia de propiedades
}

Perro.prototype = Object.create(Animal.prototype);
Perro.prototype.constructor = Perro;

Perro.prototype.hablar = function() {
    console.log(this.nombre + " ladra.");
};

function Gato(nombre) {
    Animal.call(this, nombre); // Herencia de propiedades
}

Gato.prototype = Object.create(Animal.prototype);
Gato.prototype.constructor = Gato;

Gato.prototype.hablar = function() {
    console.log(this.nombre + " maulla.");
};

let animales = [
    new Perro("Cacharro"),
    new Gato("Garfield")
];

animales.forEach(function(animal) {
    animal.hablar(); // Polimorfismo en accion
});

// Resultado:
// "Cacharro ladra."
// "Garfield maulla."

\end{lstlisting}

\subsection{Conclusiones}

JavaScript es claramente un lenguaje orientado a objetos debido a su 
capacidad para encapsular datos y métodos, proporcionar abstracción, 
soportar herencia y permitir polimorfismo.


\end{document}